import os
import psycopg2
import json
from psycopg2 import OperationalError
from datetime import datetime
from typing import Union, Dict
import utils
import datetime

DB_USER = os.environ['DB_USER']
DB_PASSWORD = os.environ['DB_PASSWORD']
DATABASE = os.environ['DB_NAME']
HOST = os.environ['DB_HOST']
conn = psycopg2.connect(
    database=DATABASE,
    user=DB_USER,
    password=DB_PASSWORD,
    host=HOST,
    port='5432'
)


# Exception generated by DB connections
class DBError(Exception):
    def __init__(self, status, msg):
        self.status = status
        self.response = json.dumps({"error": msg})


def __connect_to_db():
    global conn
    conn = psycopg2.connect(
        database=DATABASE,
        user=DB_USER,
        password=DB_PASSWORD,
        host=HOST,
        port='5432'
    )


def query(func, *args, **kwargs):
    try:
        return func(*args, **kwargs)
    except OperationalError:
        __connect_to_db()
        return func(*args, **kwargs)


def cache_login(userid, name, email, token, ttl):
    with conn.cursor() as cursor:
        # Add the user to the database if they don't already exist
        cursor.execute('''INSERT INTO ss.authors (name, email, userid) 
                        VALUES (%s, %s, %s) ON CONFLICT DO NOTHING''', (name, email, userid))
        cursor.execute(
            "INSERT INTO a.tokens (userid, token, expiration) VALUES (%s, %s, NOW() + INTERVAL '%s SECOND');", (userid, token, ttl))
        conn.commit()


def logout_user(token) -> None:
    with conn.cursor() as cursor:
        cursor.execute('DELETE FROM a.tokens WHERE token = %s;', (token,))
        conn.commit()


def logout_all(token: str) -> bool:
    with conn.cursor() as cursor:
        userid = get_userid_from_token(token, cursor)
        if userid is None:
            return False
        cursor.execute(
            'DELETE FROM a.tokens WHERE userid = %s;', (userid,))
        conn.commit()
        return True


def get_name_from_token(token: str) -> Union[None, str]:
    with conn.cursor() as cursor:
        cursor.execute('''SELECT name FROM ss.authors a
            JOIN a.tokens t ON t.userid = a.userid WHERE token = %s AND expiration > NOW()''', (token,))
        value = cursor.fetchone()
        if value is None:
            raise DBError(404, 'User for given token not found')
        return value[0]


def get_user_details(token: str):
    with conn.cursor() as cursor:
        cursor.execute('''SELECT name, email, paypal, a.userid FROM ss.authors a
        JOIN a.tokens t ON t.userid = a.userid WHERE token = %s AND expiration > NOW()''', (token,))
        value = cursor.fetchone()
        if value is None:
            raise DBError(404, 'User page not found')
        cursor.execute(
            'SELECT month, payment, paid FROM a.payments WHERE authorid = %s ORDER BY month LIMIT 12;', (value[3],))
        values = cursor.fetchall()
        return {"name": value[0], "email": value[1], "paypal": value[2],
                "payments": [{"month": p[0].strftime("%m/%Y"), "payment":float(p[1]), "paid":p[2]} for p in values]}


def story_statistics(token: str, storyid: str):
    with conn.cursor() as cursor:
        userid = get_userid_from_token(token, cursor)
        cursor.execute(
            '''SELECT s.title, COALESCE(i.purchases, 0), s.published
            FROM ss.stories s
            LEFT JOIN (
                SELECT storyid, count(*) AS purchases
                FROM ss.libraries WHERE storyid = %s GROUP BY storyid) i ON i.storyid = s.id
            WHERE id = %s AND authorid = %s''', (storyid, storyid, userid))
        response = cursor.fetchone()
        if response is None:
            raise DBError(404, 'Specified story not found')
        cursor.execute(
            '''SELECT count(*), date_trunc('month', acquire_date)
                FROM ss.libraries l
                JOIN ss.stories s ON s.id = l.storyid
                WHERE l.storyid = %s
                AND s.authorid = %s
                AND acquire_date > date_trunc('month', NOW() - INTERVAL '1 YEAR')
                GROUP BY date_trunc('month', acquire_date)
                LIMIT 12;''', (storyid, userid))
        purchases = cursor.fetchall()
        cursor.execute(
            '''SELECT count(*), date_trunc('month', time) 
            FROM ss.readings r
            JOIN ss.stories s ON s.id = r.storyid
            WHERE r.storyid = %s
            AND s.authorid = %s
            AND time > date_trunc('month', NOW() - INTERVAL '1 YEAR')
            GROUP BY date_trunc('month', time)
            LIMIT 12;''', (storyid, userid)
        )
        readings = cursor.fetchall()
        cursor.execute(
            '''SELECT count(DISTINCT(userid)), date_trunc('month', time) 
            FROM ss.readings r            
            JOIN ss.stories s ON s.id = r.storyid
            WHERE r.storyid = %s
            AND s.authorid = %s
            AND time > date_trunc('month', NOW() - INTERVAL '1 YEAR')
            GROUP BY date_trunc('month', time)
            LIMIT 12;''', (storyid, userid)
        )
        unique_readings = cursor.fetchall()
        today = datetime.date.today()
        results = {}
        for _ in range(12):
            today = today.replace(day=1)
            results[today.strftime(
                "%Y/%m")] = {'purchase': 0, 'readings': 0, 'unique_readings': 0}
            today = today - datetime.timedelta(days=1)
        for m in purchases:
            results[m[1].strftime("%Y/%m")]['purchase'] = m[0]
        for m in readings:
            results[m[1].strftime("%Y/%m")]['readings'] = m[0]
        for m in unique_readings:
            results[m[1].strftime("%Y/%m")]['unique_readings'] = m[0]
        results = list(results.items())
        results.sort(key=lambda x: x[0])
        return {
            'title': response[0],
            'lifetime_purchases': response[1],
            'published': response[2],
            'data': results
        }


def get_all_stories(token: str):
    with conn.cursor() as cursor:
        userid = get_userid_from_token(token, cursor)
        cursor.execute('''SELECT id, title, price, genre, published 
                        FROM ss.stories WHERE authorid = %s
                        ORDER BY last_modified DESC;''', (userid,))  # TODO: get this information
        response = {'stories': [{
            'id': n[0],
            'title': n[1],
            'price': n[2],
            'genre': n[3],
            'published': n[4],
        } for n in cursor.fetchall()]}
        return response


def get_story_overview(token: str, storyid: str):
    with conn.cursor() as cursor:
        userid = get_userid_from_token(token, cursor)
        cursor.execute(
            '''SELECT title, price, genre, published, summary, created, last_modified 
            FROM ss.stories WHERE id = %s AND authorid = %s;''', (storyid, userid,))
        result = cursor.fetchone()
        if result is None:
            raise DBError(
                404, 'Selected story by logged-in user not found')
        return {
            'title': result[0],
            'price': str(result[1]),
            'genre': result[2],
            'published': result[3],
            'summary': result[4],
            'created':  result[5].strftime("%m/%d/%Y, %H:%M:%S"),
            'last_modified': result[6].strftime("%m/%d/%Y, %H:%M:%S")
        }


def update_story(token: str, storyid: str, values: dict) -> int:
    with conn.cursor() as cursor:
        uid = get_userid_from_token(token, cursor)
        cursor.execute(
            'SELECT published FROM ss.stories WHERE id = %s AND authorid = %s', (storyid, uid))
        published = cursor.fetchone()
        if published is None:
            raise DBError(404, 'No story found with matching user and id')
        if published[0] != 'not published':
            raise DBError(
                403, 'Cannot update a story that has already been published')
        cursor.execute(
            '''UPDATE ss.stories 
            SET title = %s, 
            summary = %s, 
            genre = %s,
            last_modified = NOW() WHERE id = %s AND authorid = %s''',
            (values['title'], values['summary'], values['genre'], storyid, uid))
        conn.commit()


def get_story_content(token: str, storyid: str) -> Dict:
    with conn.cursor() as cursor:
        userid = get_userid_from_token(token, cursor)
        cursor.execute(
            'SELECT serialized_story FROM ss.stories WHERE id = %s AND authorid = %s;', (storyid, userid))
        result = cursor.fetchone()
        if result:
            return result[0]
        raise DBError(
            404, 'Unable to find requested story by provided author')


def create_story(token: str, title: str):
    with conn.cursor() as cursor:
        userid = get_userid_from_token(token, cursor)
        cursor.execute(
            'INSERT INTO ss.stories (title, authorid) VALUES (%s, %s);',
            (title, userid,))
        conn.commit()
        cursor.execute(
            'SELECT id FROM ss.stories WHERE title = %s;', (title,))
        return cursor.fetchone()[0]


def delete_story(token: str, storyid: str) -> str:
    with conn.cursor() as cursor:
        userid = get_userid_from_token(token, cursor)
        cursor.execute(
            'SELECT published FROM ss.stories WHERE authorid = %s AND id = %s;', (userid, storyid))
        v = cursor.fetchone()
        if v is None:
            raise DBError(
                403, 'Authorized user is not permitted to delete the given story')
        status = v[0]
        if status == 'published':
            raise DBError(403, 'Published stories may not be deleted')
        cursor.execute('DELETE FROM ss.stories WHERE id = %s;', (storyid,))
        conn.commit()


def title_exists(title: str) -> bool:
    with conn.cursor() as cursor:
        cursor.execute(
            'SELECT title FROM ss.stories WHERE title ~ %s;', (title,))
        return cursor.fetchone() is not None


def save_story_content(token: str, storyid: str, content: str) -> bool:
    with conn.cursor() as cursor:
        userid = get_userid_from_token(token, cursor)
        cursor.execute(
            'UPDATE ss.stories SET serialized_story = %s, last_modified = NOW() WHERE id = %s AND authorid = %s;', (content, storyid, userid))
        conn.commit()


def compile_and_submit_story(token: str, storyid: str):
    with conn.cursor() as cursor:
        userid = get_userid_from_token(token, cursor)
        cursor.execute(
            'SELECT published, serialized_story, title FROM ss.stories WHERE id = %s AND authorid = %s;', (storyid, userid))
        result = cursor.fetchone()
        if result is None:
            raise DBError(404, 'No such story found')
        if result[0] == 'published':
            raise DBError(
                403, 'Cannot make changes to an already published story')
        author = get_author_from_userid(userid, cursor)
        compiled = utils.compile_to_alexa(result[1], result[2], author)
        try:
            compiled = utils.validate_json(compiled)
        except utils.ValidationError as e:
            raise DBError(400, str(e))
        cursor.execute(
            "UPDATE ss.stories SET content = %s, published = 'pending', last_compiled = NOW() WHERE id = %s AND authorid = %s;", (
                json.dumps(compiled), storyid, userid)
        )
        conn.commit()
        return compiled


def get_story_preview(token, storyid):
    with conn.cursor() as cursor:
        userid = get_userid_from_token(token, cursor)
        cursor.execute(
            'SELECT published, last_compiled, last_modified, content, serialized_story, title FROM ss.stories WHERE id = %s AND authorid = %s;', (storyid, userid))
        result = cursor.fetchone()
        if result is None:
            raise DBError(
                400, "Story by given author and id doesn't exist")
        if result[0] == 'published':
            return result[3]
        author = get_author_from_userid(userid, cursor)
        if result[1] < result[2]:
            nc = utils.compile_to_alexa(result[4], result[5], author)
            cursor.execute(
                'UPDATE ss.stories SET content = %s, last_compiled = NOW() WHERE id = %s AND authorid = %s', (json.dumps(nc), storyid, userid))
            conn.commit()
            return nc
        return result[3]


def get_userid_from_token(token, cursor):
    cursor.execute(
        'SELECT userid FROM a.tokens WHERE token = %s AND expiration > NOW();', (token,))
    userid = cursor.fetchone()
    if userid:
        return userid[0]
    raise DBError(403, 'Invalid or expired token provided')


def get_author_from_userid(userid, cursor):
    cursor.execute('SELECT name FROM ss.authors WHERE userid = %s;', (userid,))
    return cursor.fetchone()[0]
